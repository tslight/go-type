package cli

import (
	"testing"

	tea "github.com/charmbracelet/bubbletea"
)

// TestNewMenuModel tests menu model creation
func TestNewMenuModel(t *testing.T) {
	tests := []struct {
		name           string
		width          int
		height         int
		validateWidth  func(int) bool
		validateHeight func(int) bool
	}{
		{
			name:           "standard terminal size",
			width:          80,
			height:         24,
			validateWidth:  func(w int) bool { return w == 80 },
			validateHeight: func(h int) bool { return h == 24 },
		},
		{
			name:           "large terminal",
			width:          120,
			height:         40,
			validateWidth:  func(w int) bool { return w == 120 },
			validateHeight: func(h int) bool { return h == 40 },
		},
		{
			name:           "small terminal",
			width:          40,
			height:         12,
			validateWidth:  func(w int) bool { return w == 40 },
			validateHeight: func(h int) bool { return h == 12 },
		},
		{
			name:           "very small terminal",
			width:          20,
			height:         10,
			validateWidth:  func(w int) bool { return w == 20 },
			validateHeight: func(h int) bool { return h == 10 },
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			manager := NewTestContentManager()
			manager := NewTestContentManager()
			m := NewMenuModel(manager, manager, tt.width, tt.height)

			if m == nil {
				t.Fatal("NewMenuModel returned nil")
			}

			if !tt.validateWidth(m.terminalWidth) {
				t.Errorf("Expected terminal width %d, got %d", tt.width, m.terminalWidth)
			}

			if !tt.validateHeight(m.terminalHeight) {
				t.Errorf("Expected terminal height %d, got %d", tt.height, m.terminalHeight)
			}

			// Check initial state
			if m.selectedIndex != 0 {
				t.Errorf("Expected initial selected index 0, got %d", m.selectedIndex)
			}
		})
	}
}

// TestMenuModelInit tests menu model initialization
func TestMenuModelInit(t *testing.T) {
	m := NewMenuModel(80, 24)

	cmd := m.Init()
	if cmd != nil {
		t.Errorf("MenuModel.Init() should return nil, got %v", cmd)
	}
}

// TestMenuModelUpdate tests menu model update handling
func TestMenuModelUpdate(t *testing.T) {
	m := NewMenuModel(80, 24)

	tests := []struct {
		name    string
		message tea.Msg
	}{
		{
			name:    "window size message",
			message: tea.WindowSizeMsg{Width: 100, Height: 30},
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			newModel, cmd := m.Update(tt.message)

			if newModel == nil {
				t.Error("Update should return a non-nil model")
			}

			// Most messages should return nil command
			if cmd != nil {
				t.Logf("Update returned command (expected in some cases): %v", cmd)
			}
		})
	}
}

// TestMenuModelView tests menu model rendering
func TestMenuModelView(t *testing.T) {
	m := NewMenuModel(80, 24)

	view := m.View()

	if view == "" {
		t.Error("MenuModel.View() should return non-empty string")
	}

	// View should contain some reasonable content
	if len(view) < 5 {
		t.Errorf("MenuModel.View() returned suspiciously short content: %d chars", len(view))
	}
}

// TestMenuModelSelectedBook tests book selection functionality
func TestMenuModelSelectedBook(t *testing.T) {
	m := NewMenuModel(80, 24)

	// Test SelectedBook method if it exists
	book := m.SelectedBook()

	// Should return a book or nil
	if book != nil {
		if book.ID == 0 && book.Name == "" {
			t.Error("SelectedBook returned empty book")
		}
	}
}

// TestMenuModel_Dimensions tests various dimension scenarios
func TestMenuModel_Dimensions(t *testing.T) {
	tests := []struct {
		name   string
		width  int
		height int
	}{
		{"minimal width", 1, 1},
		{"minimal height", 80, 1},
		{"standard", 80, 24},
		{"widescreen", 160, 50},
		{"mobile", 40, 20},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			manager := NewTestContentManager()
			m := NewMenuModel(manager, tt.width, tt.height)
			if m == nil {
				t.Fatal("NewMenuModel returned nil")
			}

			// Should handle all dimensions without panicking
			view := m.View()
			if view == "" {
				t.Error("View should produce output for any dimension")
			}
		})
	}
}

// TestMenuModel_StateTransitions tests state transitions
func TestMenuModel_StateTransitions(t *testing.T) {
	m := NewMenuModel(80, 24)

	// Should start with selectedIndex 0
	if m.selectedIndex != 0 {
		t.Errorf("Initial selectedIndex should be 0, got %d", m.selectedIndex)
	}

	// Try updating with resize
	newModel, _ := m.Update(tea.WindowSizeMsg{Width: 100, Height: 30})
	if newModel == nil {
		t.Error("Update should return valid model")
	}
}

// BenchmarkMenuModelView benchmarks menu rendering
func BenchmarkMenuModelView(b *testing.B) {
	m := NewMenuModel(80, 24)

	b.ResetTimer()
	for i := 0; i < b.N; i++ {
		_ = m.View()
	}
}

// BenchmarkMenuModelUpdate benchmarks menu update
func BenchmarkMenuModelUpdate(b *testing.B) {
	m := NewMenuModel(80, 24)
	msg := tea.WindowSizeMsg{Width: 80, Height: 24}

	b.ResetTimer()
	for i := 0; i < b.N; i++ {
		_, _ = m.Update(msg)
	}
}
